# RBAC / DTO / Filter Attribute

### ğŸ’¡ CrÃ©ation de `DTO`

## ğŸ“ Tes notes

DÃ©taille ce que tu as appris ici,Â surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Pour rappel, passer toutes les donnÃ©es de la base de donnÃ©es aux composants `React` nâ€™est pas recommandÃ©. Des donnÃ©es sensibles stockÃ©es en base de donnÃ©es pourraient se retrouver exposÃ©es.

Pour cela, nous pouvons introduire une couche `DAL (Data Acces Layer)` qui a pour rÃ´le dâ€™accÃ©der aux donnÃ©es et de ne retourner que les champs utiles pour la vue. Par exemple :

```tsx
// Get user Dal ne retoune que 3 champs
export const getConnectedUser = cache(async () => {
  const user = await getUser()
  if (!user) return
  return userDTO(user as User)
})

export function userDTO(user: User): UserDTO | undefined {
  if (!user) return undefined

  return {
    email: user?.email ?? '',
    name: user?.name ?? '',
    role: user?.role,
  }
}
```

ğŸ“‘ Le lien vers la doc [https://nextjs.org/blog/security-nextjs-server-components-actions#data-access-layer](https://nextjs.org/blog/security-nextjs-server-components-actions#data-access-layer)

Dans cet exemple, le `DTO` supprime des champs. On pourrait utiliser la suppression des champs de maniÃ¨re optionnelle basÃ©e sur le `ROLE` et la configuration `RBAC`.

Exemple : Un `user` qui lit des donnÃ©es `health` dâ€™autres `user`, tous les champs sont autorisÃ©s sauf `category`

```tsx
 {
    role: 'user',
    resource: 'health',
    action: 'read:any',
    attributes: '*,!category',
  },
  // le champs role skip sur update dun user
   {
    role: 'user',
    resource: 'health',
    action: 'update:own',
    attributes: '*,!role',
  },
```

Pour gagner du temps, nous avons Ã  notre disposition 2 fonctions, la premiÃ¨re : `canAccessField` :

- `canAccessField(permission.attributes,'role')`
  - Va retourner `true/false` si le champ est accessible ou non.

```tsx

export function canAccessField(attributes: string[], field: string): boolean {
  // VÃ©rifie s'il y a une exclusion pour le champ spÃ©cifiÃ©, par exemple "!rating"
  const isFieldExcluded = attributes.some((attr) =>
    new RegExp(`^!${field}$`).test(attr)
  )

  // VÃ©rifie si `*` est prÃ©sent (accÃ¨s Ã  tous les champs) et le champ n'est pas exclu
  const hasAllAttributes = attributes.includes('*')

  // Si `*` est prÃ©sent mais le champ est explicitement exclu, accÃ¨s refusÃ©
  if (hasAllAttributes && isFieldExcluded) {
    return false
  }

  // Si le champ est explicitement exclu, retour `false`
  if (isFieldExcluded) {
    return false
  }

  // Si `*` est prÃ©sent et aucune exclusion, retour `true`
  if (hasAllAttributes) {
    return true
  }

  // Si le champ est explicitement mentionnÃ© dans les attributs, accÃ¨s accordÃ©
  return attributes.includes(field)
}
```

et `filterRessourceFields` : Permet de filtrer les attributs grÃ¢ce Ã  `perms.filter(ressource)`

```tsx
export const filterRessourceFields = <T>(
  user: User | undefined,
  ressourceType: Ressource,
  action: GrantAction,
  ressources?: T[], // La ressource est maintenant de type gÃ©nÃ©rique T
  ressourceUid?: string
): T[] => {
  const perms = permissionAcces(user, ressourceType, action, ressourceUid)
  //console.log("perms", perms)
  // Pour tous les Ã©lÃ©ments de `ressources`, on filtre les attribus perms.filter(ressource) rbac
  const filteredRessource: T[] =
    ressources?.map((ressource) => {
      // eslint-disable-next-line unicorn/no-array-callback-reference
      return perms.filter(ressource) as T // Assure que le type T est respectÃ©
    }) ?? []

  return filteredRessource
```

Nous avons donc, au niveau des autorisations `Heath` et `Finance`, 2 fonctions spÃ©cialisÃ©es Ã  notre disposition :

- `filterFinancesAttributes`
- `canSeeFinanceField`
- `filterHealthsAttributes`
- `canSeeHealthField`

Nous avons Ã©galement ajoutÃ© 2 fichiers `DAL` :

- `finance-dal.ts` : `getFinancesWithPaginationByYear`
- `health-dal.ts` : `getHealthsWithPaginationByWeek`

Et les routes et composants appellent maintenant les `DAL` au lieu des services directement.

## Exercice

Dans cet exercice, nous allons travailler sur les finances et filtrer la `catÃ©gorie` et le `label` car ce sont des informations privÃ©es (mais le `owner` ou `admin` peut les voir). Nous avons donc rajoutÃ© la config pour les rÃ´les publics :

```tsx
{
    role: 'public',
    resource: 'finance',
    action: 'read:any',
    attributes: '*,!label,!category',
  },
```

- **ğŸ¶** Dans **`finance-dal`,** crÃ©e un `DTO` pour filtrer ces 2 champs.

Il va falloir crÃ©er 2 fonctions (`canSeeCategory`, `canSeeLabel`) et filtrer dans le `DTO`.

Fichiers

- `app/dal/finance-dal.ts`

## Bonus

### 1. ğŸš€ Patterns : Filtre automatique

- **ğŸ¶** Nous allons filtrer tout les champs automatiquement avec **`filterHealthsAttributes`**

Fichiers

- `src/app/dal/health-dal.ts`

## Aller plus loin

ğŸ“‘ Le lien vers la doc [https://fr.wikipedia.org/wiki/ContrÃ´le*d'accÃ¨s*Ã _base_de_rÃ´les](https://fr.wikipedia.org/wiki/Contr%C3%B4le_d%27acc%C3%A8s_%C3%A0_base_de_r%C3%B4les)

## Ils vont tâ€™aider

- **ğŸ¶ Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **ğŸ¤– Ash le Robot** : _Ash le Robot te donnera du code utile._
- **ğŸš€ Julia La roquette** : _Julia te donnera des dÃ©fis supplÃ©mentaires._
- **â›ï¸ Hulk le Marteau** : _Quand du code Ã  supprimer est prÃ©sent_
- **ğŸ‘¨â€âœˆï¸ Hugo le chef de projet** : _Va t'aider sur les spÃ©cifications du projet_

## ğŸœ Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20Mastery&entry.1430994900=9.SAAS%20Entrepreneur&entry.533578441=13%20rbac-dto-filter%20attribute).
