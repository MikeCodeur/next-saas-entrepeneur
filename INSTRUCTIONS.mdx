# RBAC / DTO / Filter Attribute

### 💡 Création de `DTO`

## 📝 Tes notes

Détaille ce que tu as appris ici, sur une page [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

Pour rappel, passer toutes les données de la base de données aux composants `React` n’est pas recommandé. Des données sensibles stockées en base de données pourraient se retrouver exposées.

Pour cela, nous pouvons introduire une couche `DAL (Data Acces Layer)` qui a pour rôle d’accéder aux données et de ne retourner que les champs utiles pour la vue. Par exemple :

```tsx
// Get user Dal ne retoune que 3 champs
export const getConnectedUser = cache(async () => {
  const user = await getUser()
  if (!user) return
  return userDTO(user as User)
})

export function userDTO(user: User): UserDTO | undefined {
  if (!user) return undefined

  return {
    email: user?.email ?? '',
    name: user?.name ?? '',
    role: user?.role,
  }
}
```

📑 Le lien vers la doc [https://nextjs.org/blog/security-nextjs-server-components-actions#data-access-layer](https://nextjs.org/blog/security-nextjs-server-components-actions#data-access-layer)

Dans cet exemple, le `DTO` supprime des champs. On pourrait utiliser la suppression des champs de manière optionnelle basée sur le `ROLE` et la configuration `RBAC`.

Exemple : Un `user` qui lit des données `health` d’autres `user`, tous les champs sont autorisés sauf `category`

```tsx
 {
    role: 'user',
    resource: 'health',
    action: 'read:any',
    attributes: '*,!category',
  },
  // le champs role skip sur update dun user
   {
    role: 'user',
    resource: 'health',
    action: 'update:own',
    attributes: '*,!role',
  },
```

Pour gagner du temps, nous avons à notre disposition 2 fonctions, la première : `canAccessField` :

- `canAccessField(permission.attributes,'role')`
  - Va retourner `true/false` si le champ est accessible ou non.

```tsx

export function canAccessField(attributes: string[], field: string): boolean {
  // Vérifie s'il y a une exclusion pour le champ spécifié, par exemple "!rating"
  const isFieldExcluded = attributes.some((attr) =>
    new RegExp(`^!${field}$`).test(attr)
  )

  // Vérifie si `*` est présent (accès à tous les champs) et le champ n'est pas exclu
  const hasAllAttributes = attributes.includes('*')

  // Si `*` est présent mais le champ est explicitement exclu, accès refusé
  if (hasAllAttributes && isFieldExcluded) {
    return false
  }

  // Si le champ est explicitement exclu, retour `false`
  if (isFieldExcluded) {
    return false
  }

  // Si `*` est présent et aucune exclusion, retour `true`
  if (hasAllAttributes) {
    return true
  }

  // Si le champ est explicitement mentionné dans les attributs, accès accordé
  return attributes.includes(field)
}
```

et `filterRessourceFields` : Permet de filtrer les attributs grâce à `perms.filter(ressource)`

```tsx
export const filterRessourceFields = <T>(
  user: User | undefined,
  ressourceType: Ressource,
  action: GrantAction,
  ressources?: T[], // La ressource est maintenant de type générique T
  ressourceUid?: string
): T[] => {
  const perms = permissionAcces(user, ressourceType, action, ressourceUid)
  //console.log("perms", perms)
  // Pour tous les éléments de `ressources`, on filtre les attribus perms.filter(ressource) rbac
  const filteredRessource: T[] =
    ressources?.map((ressource) => {
      // eslint-disable-next-line unicorn/no-array-callback-reference
      return perms.filter(ressource) as T // Assure que le type T est respecté
    }) ?? []

  return filteredRessource
```

Nous avons donc, au niveau des autorisations `Heath` et `Finance`, 2 fonctions spécialisées à notre disposition :

- `filterFinancesAttributes`
- `canSeeFinanceField`
- `filterHealthsAttributes`
- `canSeeHealthField`

Nous avons également ajouté 2 fichiers `DAL` :

- `finance-dal.ts` : `getFinancesWithPaginationByYear`
- `health-dal.ts` : `getHealthsWithPaginationByWeek`

Et les routes et composants appellent maintenant les `DAL` au lieu des services directement.

## Exercice

Dans cet exercice, nous allons travailler sur les finances et filtrer la `catégorie` et le `label` car ce sont des informations privées (mais le `owner` ou `admin` peut les voir). Nous avons donc rajouté la config pour les rôles publics :

```tsx
{
    role: 'public',
    resource: 'finance',
    action: 'read:any',
    attributes: '*,!label,!category',
  },
```

- **🐶** Dans **`finance-dal`,** crée un `DTO` pour filtrer ces 2 champs.

Il va falloir créer 2 fonctions (`canSeeCategory`, `canSeeLabel`) et filtrer dans le `DTO`.

Fichiers

- `app/dal/finance-dal.ts`

## Bonus

### 1. 🚀 Patterns : Filtre automatique

- **🐶** Nous allons filtrer tout les champs automatiquement avec **`filterHealthsAttributes`**

Fichiers

- `src/app/dal/health-dal.ts`

## Aller plus loin

📑 Le lien vers la doc [https://fr.wikipedia.org/wiki/Contrôle*d'accès*à_base_de_rôles](https://fr.wikipedia.org/wiki/Contr%C3%B4le_d%27acc%C3%A8s_%C3%A0_base_de_r%C3%B4les)

## Ils vont t’aider

- **🐶 Mowgli le Chien** : _Mowgli te guidera dans chaque exercice._
- **🤖 Ash le Robot** : _Ash le Robot te donnera du code utile._
- **🚀 Julia La roquette** : _Julia te donnera des défis supplémentaires._
- **⛏️ Hulk le Marteau** : _Quand du code à supprimer est présent_
- **👨‍✈️ Hugo le chef de projet** : _Va t'aider sur les spécifications du projet_

## 🐜 Feedback

Remplir le formulaire le [formulaire de FeedBack](https://go.mikecodeur.com/cours-next-avis?entry.1912869708=Next%20Mastery&entry.1430994900=9.SAAS%20Entrepreneur&entry.533578441=13%20rbac-dto-filter%20attribute).
